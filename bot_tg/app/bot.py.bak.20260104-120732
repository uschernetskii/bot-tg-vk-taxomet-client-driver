import os, json, re, uuid, asyncio, logging
import httpx
from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import CommandStart
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton,
    WebAppInfo
)
from aiogram.utils.keyboard import ReplyKeyboardBuilder

TG_BOT_TOKEN = os.getenv("TG_BOT_TOKEN","")
PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL","https://taxi.brakonder.ru")
BACKEND_INTERNAL_URL = os.getenv("BACKEND_INTERNAL_URL","http://backend:8000")
INTERNAL_TOKEN = os.getenv("INTERNAL_TOKEN","")

TG_ADMIN_GROUP_ID = int(os.getenv("TG_ADMIN_GROUP_ID","0"))
TG_NOTIFY_GROUP_ID = int(os.getenv("TG_NOTIFY_GROUP_ID","0"))

DRIVER_REG_LINK = os.getenv("DRIVER_REG_LINK","")
VPN_BOT_LINK = os.getenv("VPN_BOT_LINK","https://t.me/brakoknder_pn_bot")

NEARBY_RADIUS_METERS = int(os.getenv("NEARBY_RADIUS_METERS","5"))

if not TG_BOT_TOKEN:
    raise SystemExit("TG_BOT_TOKEN is required")

bot = Bot(TG_BOT_TOKEN)
dp = Dispatcher()

def kb_main():
    b = ReplyKeyboardBuilder()
    b.button(text="üöï –ó–∞–∫–∞–∑–∞—Ç—å —Ç–∞–∫—Å–∏")
    b.button(text="üó∫Ô∏è –ö–∞—Ä—Ç–∞ (MiniApp)")
    b.button(text="üìç –Ø –≤–æ–¥–∏—Ç–µ–ª—å ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –≥–µ–æ")
    b.button(text="üßë‚Äç‚úàÔ∏è –°—Ç–∞—Ç—å –≤–æ–¥–∏—Ç–µ–ª–µ–º")
    b.button(text="üõ°Ô∏è –û–±—Ö–æ–¥/–í–ü–ù")
    b.adjust(2,2,1)
    return b.as_markup(resize_keyboard=True)

def kb_driver_geo():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ø–æ–∑–∏—Ü–∏—é", request_location=True)],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )

def inline_open_map():
    # –í–ê–ñ–ù–û: –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤, –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø—É—Ç—å
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(
            text="üó∫Ô∏è –û—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç—É",
            web_app=WebAppInfo(url=f"{PUBLIC_BASE_URL}/miniapp/")
        )]
    ])

def normalize_driver_id(text: str):
    digits = re.sub(r"\D+","", text or "")
    if not digits:
        return None
    return int(digits.lstrip("0") or "0")

async def backend_post(path: str, payload: dict):
    headers={"x-internal-token": INTERNAL_TOKEN}
    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.post(f"{BACKEND_INTERNAL_URL}{path}", json=payload, headers=headers)
        r.raise_for_status()
        return r.json()

@dp.message(CommandStart())
async def start(m: types.Message):
    await m.answer(
        "–ë–´–°–¢–†–û –ò –¢–û–ß–ö–ê üöï\n\n"
        "‚Ä¢ –ó–∞–∫–∞–∑ —á–µ—Ä–µ–∑ –∫–∞—Ä—Ç—É (MiniApp)\n"
        f"‚Ä¢ –ú–∞—à–∏–Ω—ã —Ä—è–¥–æ–º ~ {NEARBY_RADIUS_METERS}–º\n"
        "‚Ä¢ –í–æ–¥–∏—Ç–µ–ª—å: –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–π –≥–µ–æ–ø–æ–∑–∏—Ü–∏—é\n\n"
        "–í—ã–±–∏—Ä–∞–π –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=kb_main()
    )

@dp.message(F.text == "üó∫Ô∏è –ö–∞—Ä—Ç–∞ (MiniApp)")
async def map_open(m: types.Message):
    await m.answer("–û—Ç–∫—Ä—ã–≤–∞–π –∫–∞—Ä—Ç—É, —Å—Ç–∞–≤—å –ø–∏–Ω—ã –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–π –∑–∞–∫–∞–∑:", reply_markup=inline_open_map())

@dp.message(F.text == "üöï –ó–∞–∫–∞–∑–∞—Ç—å —Ç–∞–∫—Å–∏")
async def order(m: types.Message):
    await m.answer(
        "–ó–∞–∫–∞–∑ –¥–µ–ª–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ –∫–∞—Ä—Ç—É:\n"
        "1) –û—Ç–∫—Ä–æ–π MiniApp\n2) –ü–æ—Å—Ç–∞–≤—å –û—Ç–∫—É–¥–∞/–ö—É–¥–∞\n3) –ù–∞–∂–º–∏ '–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ –±–æ—Ç–∞'",
        reply_markup=inline_open_map()
    )

@dp.message(F.text == "üìç –Ø –≤–æ–¥–∏—Ç–µ–ª—å ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –≥–µ–æ")
async def driver(m: types.Message):
    await m.answer("–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –∏ –æ—Ç–ø—Ä–∞–≤—å –≥–µ–æ–ø–æ–∑–∏—Ü–∏—é (–º–æ–∂–Ω–æ –æ–±–Ω–æ–≤–ª—è—Ç—å):", reply_markup=kb_driver_geo())

@dp.message(F.text == "üßë‚Äç‚úàÔ∏è –°—Ç–∞—Ç—å –≤–æ–¥–∏—Ç–µ–ª–µ–º")
async def reg(m: types.Message):
    if DRIVER_REG_LINK:
        await m.answer("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–æ–¥–∏—Ç–µ–ª—è:", reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üßë‚Äç‚úàÔ∏è –°—Ç–∞—Ç—å –≤–æ–¥–∏—Ç–µ–ª–µ–º", url=DRIVER_REG_LINK)]
        ]))
    else:
        await m.answer("DRIVER_REG_LINK –Ω–µ –∑–∞–¥–∞–Ω –≤ .env")

@dp.message(F.text == "üõ°Ô∏è –û–±—Ö–æ–¥/–í–ü–ù")
async def vpn(m: types.Message):
    await m.answer("–ë–æ—Ç –æ–±—Ö–æ–¥–∞:", reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üõ°Ô∏è @brakoknder_pn_bot", url=VPN_BOT_LINK)]
    ]))

@dp.message(F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def back(m: types.Message):
    await m.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_main())

@dp.message(F.location)
async def location(m: types.Message):
    tg_id = m.from_user.id
    lat = m.location.latitude
    lon = m.location.longitude

    # –ï—Å–ª–∏ driver_id –Ω–µ –∏–∑–≤–µ—Å—Ç–µ–Ω ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º tg_id
    driver_id = normalize_driver_id(m.from_user.username or "") or tg_id

    await backend_post("/api/drivers/location", {
        "driver_id": int(driver_id),
        "tg_id": int(tg_id),
        "lat": float(lat),
        "lon": float(lon),
        "phone": None,
        "name": m.from_user.full_name
    })
    await m.answer("‚úÖ –ì–µ–æ–ø–æ–∑–∏—Ü–∏—è –≤–æ–¥–∏—Ç–µ–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")

@dp.message(F.web_app_data)
async def webapp(m: types.Message):
    try:
        data = json.loads(m.web_app_data.data)
    except Exception:
        await m.answer("–ù–µ —Å–º–æ–≥ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —Å –∫–∞—Ä—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        return

    phone = (data.get("phone") or "").strip()
    if not phone.startswith("+"):
        await m.answer("–¢–µ–ª–µ—Ñ–æ–Ω –Ω—É–∂–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ +7XXXXXXXXXX")
        return

    from_obj = data.get("from") or {}
    to_list = data.get("to") or []
    if not from_obj or not to_list:
        await m.answer("–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –û—Ç–∫—É–¥–∞ –∏ –ö—É–¥–∞.")
        return

    extern_id = f"tg-{m.from_user.id}-{uuid.uuid4().hex[:10]}"

    payload = {
        "phone": phone,
        "client_name": (data.get("client_name") or m.from_user.full_name or "").strip(),
        "comment": (data.get("comment") or "").strip(),
        "from_address": from_obj.get("address") or "",
        "from_lat": from_obj.get("lat"),
        "from_lon": from_obj.get("lon"),
        "to_addresses": [x.get("address") or "" for x in to_list],
        "to_lats": [x.get("lat") for x in to_list],
        "to_lons": [x.get("lon") for x in to_list],
        "tg_user_id": int(m.from_user.id),
        "extern_id": extern_id
    }

    try:
        res = await backend_post("/api/orders/create", payload)
    except httpx.HTTPStatusError as e:
        await m.answer(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞: {e.response.text[:1200]}")
        return

    await m.answer(f"‚úÖ –ó–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω. ID: {res.get('taxomet_order_id')}\n–û–∂–∏–¥–∞–π –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –≤–æ–¥–∏—Ç–µ–ª—è.")

async def main():
    logging.basicConfig(level=logging.INFO)
    # –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π —É–±–∏—Ä–∞–µ–º webhook, —á—Ç–æ–±—ã polling –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞–ª
    await bot.delete_webhook(drop_pending_updates=True)

    # –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ: –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–µ –±—É–¥–µ—Ç –≤—ã—Ö–æ–¥–∏—Ç—å
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())

if __name__ == "__main__":
    asyncio.run(main())

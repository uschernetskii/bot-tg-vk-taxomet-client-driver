import os, json, uuid, asyncio, logging
import httpx
from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import CommandStart
from aiogram import F
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton,
    WebAppInfo
)
from aiogram.utils.keyboard import ReplyKeyboardBuilder

TG_BOT_TOKEN = os.getenv("TG_BOT_TOKEN","")
PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL","https://taxi.brakonder.ru")
BACKEND_INTERNAL_URL = os.getenv("BACKEND_INTERNAL_URL","http://backend:8000")
INTERNAL_TOKEN = os.getenv("INTERNAL_TOKEN","")

DRIVER_REG_LINK = os.getenv("DRIVER_REG_LINK","")
VPN_BOT_LINK = os.getenv("VPN_BOT_LINK","https://t.me/brakoknder_pn_bot")
NEARBY_RADIUS_METERS = int(os.getenv("NEARBY_RADIUS_METERS","5"))

if not TG_BOT_TOKEN:
    raise SystemExit("TG_BOT_TOKEN is required")

bot = Bot(TG_BOT_TOKEN)
dp = Dispatcher()

def kb_phone():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä", request_contact=True)]],
        resize_keyboard=True
    )

def kb_main_client():
    b = ReplyKeyboardBuilder()
    b.button(text="üöï –ó–∞–∫–∞–∑–∞—Ç—å —Ç–∞–∫—Å–∏")
    b.button(text="üó∫Ô∏è –ö–∞—Ä—Ç–∞ (MiniApp)")
    b.button(text="üõ°Ô∏è –û–±—Ö–æ–¥/–í–ü–ù")
    b.adjust(2,1)
    return b.as_markup(resize_keyboard=True)

def kb_main_driver():
    b = ReplyKeyboardBuilder()
    b.button(text="üìç –Ø –≤–æ–¥–∏—Ç–µ–ª—å ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –≥–µ–æ")
    b.button(text="üó∫Ô∏è –ö–∞—Ä—Ç–∞ (MiniApp)")
    b.button(text="üßë‚Äç‚úàÔ∏è –°—Ç–∞—Ç—å –≤–æ–¥–∏—Ç–µ–ª–µ–º")
    b.button(text="üõ°Ô∏è –û–±—Ö–æ–¥/–í–ü–ù")
    b.adjust(2,2)
    return b.as_markup(resize_keyboard=True)

def kb_driver_geo():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ø–æ–∑–∏—Ü–∏—é", request_location=True)],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )

def inline_choose_role():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üôã –Ø –∫–ª–∏–µ–Ω—Ç", callback_data="role:client")],
        [InlineKeyboardButton(text="üöñ –Ø –≤–æ–¥–∏—Ç–µ–ª—å", callback_data="role:driver")],
    ])

def inline_open_map():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üó∫Ô∏è –û—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç—É", web_app=WebAppInfo(url=f"{PUBLIC_BASE_URL}/miniapp/"))]
    ])

async def backend_get(path: str):
    headers={"x-internal-token": INTERNAL_TOKEN}
    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.get(f"{BACKEND_INTERNAL_URL}{path}", headers=headers)
        r.raise_for_status()
        return r.json()

async def backend_post(path: str, payload: dict):
    headers={"x-internal-token": INTERNAL_TOKEN}
    async with httpx.AsyncClient(timeout=30) as client:
        r = await client.post(f"{BACKEND_INTERNAL_URL}{path}", json=payload, headers=headers)
        r.raise_for_status()
        return r.json()

async def ensure_registered(m: types.Message):
    tg_id = m.from_user.id
    info = await backend_get(f"/api/users/by_tg/{tg_id}")
    if not info.get("exists"):
        await m.answer("–ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å, –æ—Ç–ø—Ä–∞–≤—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ üëá", reply_markup=kb_phone())
        return None
    return info["user"]

@dp.message(CommandStart())
async def cmd_start(m: Message):
    tg_id = m.from_user.id
    user = await _api_get_user_tg(tg_id)

    if not user or not user.get("phone"):
        await m.answer(
            "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–∫–Ω–æ–ø–∫–∞ –Ω–∏–∂–µ).\n"
            "–†–æ–ª—å –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –º–µ–Ω—è—Ç—å –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç.",
            reply_markup=_kb_phone()
        )
        return

    if not user.get("current_role"):
        await m.answer("–í—ã–±–µ—Ä–∏—Ç–µ, –∫—Ç–æ –≤—ã:", reply_markup=_kb_role())
        return

    role = user.get("current_role")
    await m.answer(f"–ì–æ—Ç–æ–≤–æ ‚úÖ –¢–µ–∫—É—â–∞—è —Ä–æ–ª—å: {'–í–æ–¥–∏—Ç–µ–ª—å' if role=='driver' else '–ö–ª–∏–µ–Ω—Ç'}\n\n"
                   f"–ß—Ç–æ–±—ã –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è: –æ—Ç–ø—Ä–∞–≤—å—Ç–µ 'üîÅ –°–º–µ–Ω–∏—Ç—å —Ä–æ–ª—å' –∏–ª–∏ /role")

@dp.message(F.contact)
async def contact(m: types.Message):
    if not m.contact or m.contact.user_id != m.from_user.id:
        await m.answer("–ù—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –°–í–û–ô –Ω–æ–º–µ—Ä —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª.", reply_markup=kb_phone())
        return

    phone = (m.contact.phone_number or "").strip()
    if not phone.startswith("+"):
        if phone.startswith("8"):
            phone = "+7" + phone[1:]
        elif phone.startswith("7"):
            phone = "+" + phone
        else:
            phone = "+" + phone

    await backend_post("/api/users/upsert", {
        "tg_id": int(m.from_user.id),
        "phone": phone,
        "full_name": m.from_user.full_name
    })
    await m.answer("–ù–æ–º–µ—Ä –ø—Ä–∏–Ω—è—Ç ‚úÖ –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —Ä–æ–ª—å:", reply_markup=inline_choose_role())

@dp.callback_query(F.data.startswith("role:"))
async def set_role(cb: types.CallbackQuery):
    role = cb.data.split(":",1)[1]
    await backend_post("/api/users/set_role", {"tg_id": cb.from_user.id, "role": role})

    if role == "driver":
        await cb.message.answer("–¢—ã –≤–æ–¥–∏—Ç–µ–ª—å ‚úÖ", reply_markup=kb_main_driver())
    else:
        await cb.message.answer("–¢—ã –∫–ª–∏–µ–Ω—Ç ‚úÖ", reply_markup=kb_main_client())

    await cb.answer()

@dp.message(F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def back(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    if user.get("role") == "driver":
        await m.answer("–ú–µ–Ω—é –≤–æ–¥–∏—Ç–µ–ª—è:", reply_markup=kb_main_driver())
    else:
        await m.answer("–ú–µ–Ω—é –∫–ª–∏–µ–Ω—Ç–∞:", reply_markup=kb_main_client())

@dp.message(F.text == "üó∫Ô∏è –ö–∞—Ä—Ç–∞ (MiniApp)")
async def map_open(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    await m.answer("–û—Ç–∫—Ä—ã–≤–∞–π –∫–∞—Ä—Ç—É:", reply_markup=inline_open_map())

@dp.message(F.text == "üöï –ó–∞–∫–∞–∑–∞—Ç—å —Ç–∞–∫—Å–∏")
async def order(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    if user.get("role") != "client":
        await m.answer("–≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤. –ï—Å–ª–∏ —Ç—ã –≤–æ–¥–∏—Ç–µ–ª—å ‚Äî –∂–º–∏ ¬´–ù–∞–∑–∞–¥¬ª.")
        return
    await m.answer("–ó–∞–∫–∞–∑ –¥–µ–ª–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ –∫–∞—Ä—Ç—É:", reply_markup=inline_open_map())

@dp.message(F.text == "üìç –Ø –≤–æ–¥–∏—Ç–µ–ª—å ‚Äî –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –≥–µ–æ")
async def driver(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    if user.get("role") != "driver":
        await m.answer("–≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ –¥–ª—è –≤–æ–¥–∏—Ç–µ–ª–µ–π. –ï—Å–ª–∏ —Ç—ã –∫–ª–∏–µ–Ω—Ç ‚Äî –∂–º–∏ ¬´–ù–∞–∑–∞–¥¬ª.")
        return
    await m.answer("–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –∏ –æ—Ç–ø—Ä–∞–≤—å –≥–µ–æ–ø–æ–∑–∏—Ü–∏—é:", reply_markup=kb_driver_geo())

@dp.message(F.text == "üßë‚Äç‚úàÔ∏è –°—Ç–∞—Ç—å –≤–æ–¥–∏—Ç–µ–ª–µ–º")
async def reg(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    if DRIVER_REG_LINK:
        await m.answer("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–æ–¥–∏—Ç–µ–ª—è:", reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üßë‚Äç‚úàÔ∏è –°—Ç–∞—Ç—å –≤–æ–¥–∏—Ç–µ–ª–µ–º", url=DRIVER_REG_LINK)]
        ]))
    else:
        await m.answer("DRIVER_REG_LINK –Ω–µ –∑–∞–¥–∞–Ω")

@dp.message(F.text == "üõ°Ô∏è –û–±—Ö–æ–¥/–í–ü–ù")
async def vpn(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    await m.answer("–ë–æ—Ç –æ–±—Ö–æ–¥–∞:", reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üõ°Ô∏è –û—Ç–∫—Ä—ã—Ç—å", url=VPN_BOT_LINK)]
    ]))

@dp.message(F.location)
async def location(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    if user.get("role") != "driver":
        await m.answer("–ì–µ–æ –ø—Ä–∏–Ω–∏–º–∞—é —Ç–æ–ª—å–∫–æ –æ—Ç –≤–æ–¥–∏—Ç–µ–ª–µ–π.")
        return

    tg_id = m.from_user.id
    lat = m.location.latitude
    lon = m.location.longitude
    driver_id = tg_id  # –ø–æ–∑–∂–µ –ø—Ä–∏–≤—è–∂–µ–º –∫ Taxomet driver_id

    await backend_post("/api/drivers/location", {
        "driver_id": int(driver_id),
        "tg_id": int(tg_id),
        "lat": float(lat),
        "lon": float(lon),
        "phone": user.get("phone"),
        "name": user.get("full_name") or m.from_user.full_name
    })
    await m.answer("‚úÖ –ì–µ–æ–ø–æ–∑–∏—Ü–∏—è –≤–æ–¥–∏—Ç–µ–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")

@dp.message(F.web_app_data)
async def webapp(m: types.Message):
    user = await ensure_registered(m)
    if not user:
        return
    if user.get("role") != "client":
        await m.answer("–ó–∞–∫–∞–∑—ã —Å–æ–∑–¥–∞—ë—Ç —Ç–æ–ª—å–∫–æ –∫–ª–∏–µ–Ω—Ç.")
        return

    try:
        data = json.loads(m.web_app_data.data)
    except Exception:
        await m.answer("–ù–µ —Å–º–æ–≥ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —Å –∫–∞—Ä—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        return

    phone = (user.get("phone") or "").strip()
    if not phone:
        await m.answer("–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π –Ω–æ–º–µ—Ä —á–µ—Ä–µ–∑ /start")
        return

    from_obj = data.get("from") or {}
    to_list = data.get("to") or []
    if not from_obj or not to_list:
        await m.answer("–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –û—Ç–∫—É–¥–∞ –∏ –ö—É–¥–∞.")
        return

    extern_id = f"tg-{m.from_user.id}-{uuid.uuid4().hex[:10]}"
    payload = {
        "phone": phone,
        "client_name": (user.get("full_name") or m.from_user.full_name or "").strip(),
        "comment": (data.get("comment") or "").strip(),
        "from_address": from_obj.get("address") or "",
        "from_lat": from_obj.get("lat"),
        "from_lon": from_obj.get("lon"),
        "to_addresses": [x.get("address") or "" for x in to_list],
        "to_lats": [x.get("lat") for x in to_list],
        "to_lons": [x.get("lon") for x in to_list],
        "tg_user_id": int(m.from_user.id),
        "extern_id": extern_id
    }

    try:
        res = await backend_post("/api/orders/create", payload)
    except httpx.HTTPStatusError as e:
        await m.answer(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞: {e.response.text[:1200]}")
        return

    await m.answer(f"‚úÖ –ó–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω. ID: {res.get('taxomet_order_id')}\n–û–∂–∏–¥–∞–π –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –≤–æ–¥–∏—Ç–µ–ª—è.")

async def main():
    logging.basicConfig(level=logging.INFO)
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())

if __name__ == "__main__":
    asyncio.run(main())


@dp.message(F.contact)
async def on_contact(m: Message):
    c = m.contact
    if c.user_id and c.user_id != m.from_user.id:
        await m.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ *—Å–≤–æ–π* –Ω–æ–º–µ—Ä —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.", reply_markup=_kb_phone(), parse_mode="Markdown")
        return
    await _api_set_phone_tg(m.from_user.id, c.phone_number)
    await m.answer("–û—Ç–ª–∏—á–Ω–æ. –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:", reply_markup=_kb_role())

@dp.callback_query(F.data.startswith("role:"))
async def on_role(cb: CallbackQuery):
    role = cb.data.split(":", 1)[1]
    await _api_set_role_tg(cb.from_user.id, role)
    try:
        await cb.message.edit_text("–ì–æ—Ç–æ–≤–æ ‚úÖ –†–æ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.")
    except Exception:
        pass
    await cb.message.answer(f"–¢–µ–∫—É—â–∞—è —Ä–æ–ª—å: {'–í–æ–¥–∏—Ç–µ–ª—å' if role=='driver' else '–ö–ª–∏–µ–Ω—Ç'}\n\n"
                            f"–ß—Ç–æ–±—ã –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è: –æ—Ç–ø—Ä–∞–≤—å—Ç–µ 'üîÅ –°–º–µ–Ω–∏—Ç—å —Ä–æ–ª—å' –∏–ª–∏ /role")
    await cb.answer()

@dp.message(F.text.in_({"üîÅ –°–º–µ–Ω–∏—Ç—å —Ä–æ–ª—å", "/role"}))
async def switch_role(m: Message):
    await m.answer("–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é —Ä–æ–ª—å:", reply_markup=_kb_role())
